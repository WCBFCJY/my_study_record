# **C++ 学习**

# 一、从C到C++

## 1、与C对比异与同

- 输入

  > cin scanf

  ```c++
  cin 基本用法
  cin >> a;		//将缓冲区中的数据存入变量a
  cin >> a >> b;
  ```

- 输出

  > cout printf

  ```c++
  cout 基本用法
  cout << '变量';			//打印变量
  cout << '变量' <<endl;	//打印变量并换行，C++中没有占位符的概念
  ```

- 数据类型

```c++
一.分类
	基本类型
		int char float double "long double" bool(真1假0)
	构造类型
		数组 结构(struct) 联合(union) 枚举(enum)
	指针类型
	空类型(void)
    
二.bool类型用法
bool a = false;	//定义布尔类型变量a为假
1.if判断
if(a)
{
    //a为真则执行这块
}
else
{
    //a为假则执行这块
}
2.输出
cout << a << endl ; //a为假，会输出一个0
cout << boolalpha << a << endl; //a为假，会输出false

三.随用随定义
1.在C++中，可以在用到这个变量之前再定义，而不需要把变量定义放在代码最开头的地方
c++:
    cout << "请输入一个数字:";
	int a;		//我可以在用之前再声明
	cin >> a;
c:
	int a;		//在c语言中，声明a一定要在最开头
	printf("请输入一个数字:");
	scanf("%d",&a);
2.使用for循环的时候，循环变量可以直接声明
    for(int i = 0; i < 5 ; i++)
    {
        ......
    }

四.字符串类(std::string)
C++支持字符串类型，但这并不是其基本数据类型
要使用string类时需要引入文件<iostream>并设置相应的命名空间
```



## 2、命名空间(namespace)

可以用来分隔函数和变量，避免不同人开发的代码中使用了相同的函数名或变量名产生混淆

- ```using namespace std;```这句话有啥用

```c++
using namespace std; //将std作为默认命名空间
如果把这句话删掉，那么下方代码将不能正常运行（未声明）：
    cout << a << endl;
此时想要能够运行要手动指定命名空间：
    std::cout << a << std::endl;
```

- 定义命名空间

```c++
namespace A
{
    int count = 0;
    void fun()
    {
        cout << "A" << endl;
    }
}

namespace B
{
    int count = 0;
    void fun()
    {
        cout << "B" << endl;
    }
}
```



## 3、C++中的引用

> 引用其实就是使用&(引用符)给变量起个别名，本质上是同一个变量

- 如何引用

```c++
//定义一个int型变量aaaaaaabbbbbbccccc
int aaaaaaabbbbbbccccc = 1;		
//给aaaaaaabbbbbbccccc起一个新名字，叫abc
int &abc = aaaaaaabbbbbbccccc;	
用法：<引用的数据类型> &<别名> = <原名>;
```

- *引用作为函数参数传递

```c++
写一个函数交换变量x,y的值
void fun(int &a,int &b)
{
    int c = 0;
    c = a;
    a = b;
    b = c;
}

int x = 1, y = 2;
fun(x,y);
即可完成x,y值互换
(在C语言中想借助函数实现这个就要传入指针了，c++中传入引用变量的话是可以对变量直接操作的)
```



## [4、函数默认值](https://e-learning.51cto.com/video/56747)

在C++中支持给函数形参赋一个初值，在调用该函数的时候如果没有指定形参的值就会采用默认值

```c++
void fun(int a , int b = 5 , int c = 8)
{
    ......
}

int a = 6;
fun(a);		//这个时候，函数fun中a = 6 , b = 5 , c = 8
fun(a,a);	//这个时候，函数fun中a = 6 , b = 6 , c = 8

*但是要注意，给形参默认值的时候要从最后一个变量开始而且建议在声明时赋值
void fun(int a , int b = 5 , int c); //这样写就不对了，要改成：
    void fun(int a , int b , int c = 5);
```



## 5、函数重载

同一作用域下，名字相同，参数不同（可以是参数个数/类型/顺序不同）的多个函数互称为重载函数

> *main()函数不能重载，有且只有一个！

```c++
实例：比大小函数的重载
随着参数个数的不同，比大小函数的算法也不同，但为了方便，这些函数名都叫max1，调用的时候系统会根据参数类型的不同自动选择合适的函数调用
int max1(int a , int b);			//一号函数
int max1(int a , int b , int c);	//二号函数
int max1(int* a , int* b);			//三号函数

void main()
{
    int a = 5 , b = 10 , c = 20;
    max1(a,b);		//这个时候会调用一号函数
    max1(a,b,c);	//这个时候会调用二号函数
    max1(&a,&b);	//这个时候会调用三号函数
}

int max1(int a , int b)
{
    return a >= b ? a : b;	//意思是a大于等于b的话返回a，否则b
}
int max1(int a , int b , int c)
{
    if(a >= b)
    {
        if(a >= c)
        {return a;}
        else{return c;}
    }
    else
    {
        if(b >= c)
        {return b;}
        else{return c;}
    }
}
int max1(int* a , int* b)
{
    return *a >= *b ? *a : *b;
}
```



## 6、内存管理

程序使用的内存区域分为

- 栈区（stack）
  - 由编译器自动分配释放
- 全局区（static）
  - 存放全局变量、静态数据、常量
- 文字常量区
  - 字符串常量存放于此，程序结束后由系统释放
- 程序代码区
  - 存放函数体的二进制代码
- **堆区（heap）**
  - 由程序员向系统申请/释放
  - 申请内存```new```
  - 释放内存```delete```（忘了释放内存会导致内存泄露，可能会导致程序崩溃）

```c++
堆区操作示例
-申请一块内存：
void main()
{
    int* p = new int;	//申请一个int类型的内存
    if(NULL == P)		//判断内存申请成功与否，没成功说明内存不足，报错
    {
        cout << "内存申请失败！" << endl;
    }
    *p = 30;		//给申请到的内存赋值
    cout << "内存申请成功！" << endl;
    delete p;		//释放内存
    p = NULL;		//指针复位
}

-申请一段内存：
void main()
{
    int* p = new int[100];	//申请含100个int类型的数组的内存
    if(NULL == P)
    {
        cout << "内存申请失败！" << endl;
    }
    cout << "内存申请成功！" << endl;
    p[0] =15;		//给申请到的内存赋个值
    delete []p;		//释放内存，注意区别！！
    p = NULL;		//指针复位，忘了的话会导致很严重的后果
}
```



## 7、输入与输出

内存中的数据在断电之后就会消失，为了不让这些数据消失，我们可以将那些需要存储的数据存入硬盘中，这种行为称为输出。反之，从硬盘中载入数据的过程，称为输入。

```c++
#include <fstream>	//以下函数需要这个

输出：将文本信息存入txt中
ofstream myFile("D:\\TEST\\1.txt", ios::out );
myFile << "hello C++" << endl;
myFile.close();

输入：将txt中的文本信息存入变量中
char ch;
ifstream myFile("D:\\TEST\\1.txt", ios::in );
myFile >> ch;
myFile.close();
```

- 常用函数

|  ios::app   |                  将输出数据添加到文件的结尾                  |
| :---------: | :----------------------------------------------------------: |
|  ios::ate   | 将一个文件打开作为输出文件 ，并移动到文件尾。可以在文件的任何位置写数据 |
|   ios::in   |                   打开一个文件作为输入文件                   |
|  ios::out   |                   打开一个文件作为输出文件                   |
| ios::trunc  |             如果文件有内容则将文件内容丢弃(默认)             |
| ios::binary |               打开一个文件进行二进制输入或输出               |



## 8、常量(const)

一旦定义就不能再改变的量叫做常量（给常量赋值会报错！）

定义的方式有两种```#define （宏定义，预编译器）```和```const```

> 需要特别注意的是指针常量的定义

- **[只读指针]**不能赋值的指针常量的定义（*p = 8 不可用）

​		```int const* p```或```const int* p```

- **[永久指针]**永远指向一个变量的指针常量的定义（*p = &c 不可用）

​		```int* const p```

- **[永久只读指针]**不能赋值且永远指向一个变量的指针常量的定义

​		```int const * const p```或```const int * const p```



# 二、面向对象基础

## 1、类与对象

举个例子，iphone、荣耀、魅族都是手机，其中iphone、荣耀、魅族叫做对象，手机叫做类。手机类是对这些对象功能的抽象概括。

- 类的定义

```c++
class phone			//class叫做关键字，用来定义类，phone叫做类名
{
  public:
  //数据成员（属性）
  char name[20];
  int color;
  int type;
  //成员函数（方法）
  void callup();
  private:
  void fun();
};
//类就像是结构体的升级版，类中可以有数据成员，更可以有函数！
```

- 访问限定符

> 可以使用访问限定符限制类中成员的访问

|  限定符   |     权限     |
| :-------: | :----------: |
|  public   |     公共     |
|  private  | 私有（默认） |
| protected |    受保护    |

- **C++**中类与结构体的区别
  - 关键字不同
    - 类Class
    - 结构体Struct
  - 默认权限不同
    - 类默认权限为private
    - 结构体默认权限为public



## 2、封装

有的时候你不希望外界直接去读写你的变量，这个时候你可以封装这个变量

```c++
例子：封装年龄
class student
{
public:
    void set_age(int age_set)
    {
        if(age_set < 200 && age_set >= 0)
        age = age_set;
    }
    int get_age()
    {
        return age;
    }
private:
    int age;
};
在这里面，我把年龄设为私有的，任何人不得访问，然后在公共区设置了两个函数，其他人可以通过调用这个函数修改或者得到年龄的值。同时，在修改年龄的时候还能通过set_age函数判断年龄是否合法，避免输入一个非法的年龄。如果不希望别人修改年龄，让年龄是只读的，那么就不要写set_age函数。
```



## 3、类的实例化及成员访问

> 类的成员就是我们说的“对象”

- 栈中定义```student xiaowang```;

> 获取xiaowang的年龄```xiaowang.get_age();```

- 堆中定义```student* p = new student();```

> 获取p的年龄```p->get_age();```

- 批量定义```student* p = new student[20]; //通过对象数组定义了20个学生```

> 获取1号学生的年龄```p[0].get_age();```
>
> 释放内存```delete []p;	p = NULL;```



## 4、类内定义与类外定义

### **内联函数(inline)**

普通函数调用的时候需要先去寻找函数，执行函数，返回函数结果

而内联函数可以直接在main()中执行，省去了寻找函数和返回结果的过程，能够节省时间

- 什么函数能够成为内联函数

	一定得是结构简单的函数，不能太复杂

- 如何定义内联函数

	- 在类内定义的函数

		即函数体写在类内，形如```void fun(){}```

	- 在函数前加入关键词inline

		```例如：inline int fun(){......}```

​	  *需要注意的是，函数最终是否是内联函数要取决于编译器，你的“定义”只是建议		编译器把这个函数编译为内联函数，但如果函数本身太过于复杂，编译器仍然不		会将其编译为内联函数。

- 与宏函数的区别

​		宏函数通过预编译器生成，本质上是字符串替换，不做类型检查，风险大

​		内联函数通过编译器生成

### **类外定义**

与类内定义相对的一个概念，类外定义是把函数声明写在了类内，而函数实现写在类外

```c++
形如：
class Car
{
public:
    void fun();
};
void Car::fun()
{
    ......
}
```

### 分文件定义

> 和C差不多的，多文件编程

- 操作步骤
	- 新建一个头文件(.h)，把类的声明写进去
	- 再把函数实现写在另一个文件(.cpp)
- 注意事项
	- 在使用这种方法的时候别忘了引入功能所需的头文件并设置命名空间
	- 在include自己建的头文件的时候用```""```别用```<>```（这两符号背后的文件查找方式不同，用错找不到了就）

### 类的命名规范

- **类名**每个单词的首字母大写

- **文件名**同类名(Car.h/Car.cpp)

- **函数名**第二个单词首字母大写

- **数据成员**以```m_数据类型首字母```做前缀，后面想加啥加啥，但是第一个英文要大写

## 5、构造函数

在类实例化过程中，想要对象具有初始值，除了手动调用函数进行初始化外，我们可以考虑使用构造函数

- 构造函数的特点
	- 实例化对象时自动调用，以进行一些初始化操作
	- 构造函数名与类名相同，且没有返回值(连void都没有)
	- 没有自定义构造函数，系统才会提供默认构造函数

- 构造函数的用法

```c++
不带参构造函数：
class Student
{
public:
    Student()	//这个就叫做构造函数，默认的构造函数内部没有代码，走个形式
    {
        m_strName = "";
        m_iAge = 15;
    }
private:
    string m_strName;
    int m_iAge;
}
带参构造函数（此时实例化方式有所不同）：
class Student
{
public:
    Student(int age,string Name)
    {
        m_strName = Name;
        m_iAge = age;
    }
    student(){};	//这个就是系统默认的构造函数
private:
    string m_strName;
    int m_iAge;
}
//栈中定义
Student stu_01(15,"xiaohong");
//堆中定义
Student* p = new Student(15,"xiaolan");

**构造函数也可以类外定义，但记得要在类内留下声明
**构造函数同样支持参数默认值和重载
```

- 初始化列表

	可以设定某个数据成员生成时的默认值（比起构造函数体中的二次赋值，这个更快，而且属于一次赋值，因此可以给常量赋值）

```c++
class Car
{
public:
    //形式就是在构造函数后面加个冒号写上变量名，打个括号，括号内是初始值
    Car():m_iWheel_count(4),m_iProduceyear(2022)
    {}
private:
    const int m_iWheel_count;
    const int m_iProduceyear;
}

在这里我们设定了常量m_iWheel_count的值为4，m_iProduceyear的值为2022
如果构造函数带有形参的话，这个括号内可以填形参，用形参的值初始化
```

### 拷贝构造函数

> 拷贝构造函数在用户没有自定义的情况下由系统自动生成，用来复制生成一个新对象

在一个类中，实例化一个新对象的时候可以让这个对象内的各项数值和类中的某个对象一样（就像把这个对象复制了一份一样）

- 初始化方式

	- 直接初始化

		用法：```Student stu2 = stu1;```

	- 复制初始化

		用法：```Student stu2(stu1);```

这两种方式都是系统调用**拷贝构造函数**，创建一个stu2对象，并使其各项数值同stu1

- 拷贝构造函数的声明(Student是类名)

​		```Student(const Student &);```



## 6、析构函数

> 在对象销毁时系统会自动调用析构函数

- 析构函数的特点
	- 函数名形如```~类名```
	- 没有参数
	- 没有返回值
	- 不能重载

- 析构函数的声明

​		```~Student();```

- 构造函数与析构函数
	- 构造函数是实例化一个对象时用的
	- 析构函数是销毁一个对象时用的
	- 在用户没有自定义的情况下这两个函数由系统默认给出
	- 通过自定义这两函数可以让对象在生成/销毁时执行一些顺带操作



## 7、对象成员

在一个对象里面可以包含其它对象

例如：房子类里面有家具类

初始化的时候，系统会从最里层的类开始调用构造函数，一层一层包起来

销毁对象的时候，系统会从最外层开始调用析构函数，一层一层拆掉

### 对象指针成员

在一个对象里面可以包含指向其它对象的指针

包含指针与上面有所不同，在用到这个指针对象的时候才会调用构造函数对其进行初始化



## 8、静态成员

> 静态成员不依赖于对象，没对象也可以调用

- 静态成员的概念

	静态成员是类中定义的一个全局变量，即便这个类没有实例化也能够访问，同时其数量不会随着对象的实例化而增加（实例化的所有对象的静态成员是同一个）

- 静态成员的定义

​		在类中写```static <数据类型> <变量名>;```

​		在类外进行初始化```<数据类型> <变量名> = <初始值>;```

- 静态成员函数的声明

​		```static <返回值类型> <函数名>();```

​		在声明的时候要加static，写函数头的时候就不用了！

- 注意事项
	- 静态数据成员与**类**同生死
	- 静态成员函数中只能使用静态数据成员
	- 非静态成员函数可以使用静态数据成员



## 9、this指针

每个对象有自己独有的this指针，为了标记类中的数据成员属于哪个对象，系统会在成员函数调用前隐式传入一个this指针参数用来标记

类中的成员函数可以使用this指针，this指针指向当前对象

```c++
//有一个Student类,a是它的一个对象
void Student::fun(Student* this){};	//假设有这么个函数
//这个Student* this是成员函数自带的参数，无需手动添加
//接下来通过a调用这个函数
a.fun();
//在这个时候，fun函数中的this指针就指向a，即"this = &a;"
```



## 10、类中的常量

### 常成员函数

常成员函数不允许修改数据成员的值，其本质是函数的this指针为常量

一般成员函数```void Student::fun(Student* this){};```

常成员函数```void Student::fun(Student const* this){};```

- 常成员函数的声明```<返回值类型> <类名>::<函数名>()const;```

- 同名的普通函数和常成员函数可以构成重载

```c++
void Student::fun();		//普通函数
void Student::fun()const;	//常成员函数
/*
这两个函数为重载函数，那么怎么区分调用谁呢？
当对象是普通对象时会调用普通函数（这个对象的this指针是普通指针）
当对象是常对象时会调用常成员函数（这个对象的this指针只读指针）
*/
```

### 常对象

常对象的初始化

- 栈中定义```const <类名> <对象名>();```
- 堆中定义```<类名> const* <指针名> = new <类名>();```

常对象的引用

```c++
//假设有Student类
Student a;
Student const& b = a;	//这时b是a的引用且b为一个常对象
```

















































































































































